<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Body</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Basic styling */
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; }
        #canvas-container { flex-grow: 1; height: 100vh; position: relative; }
        #canvas-container canvas { display: block; width: 100%; height: 100%; }
        #info-panel {
            width: 300px; /* Adjust width as needed */
            height: 100vh;
            overflow-y: auto;
            flex-shrink: 0;
        }
        #loading-indicator {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 1.2em; background-color: rgba(0,0,0,0.5);
            padding: 10px 15px; border-radius: 8px; display: none; z-index: 10;
        }
        /* Style for controls guide */
        #controls-guide {
            position: absolute; /* Relative to canvas-container */
            bottom: 1rem; /* 4 */
            right: 1rem; /* 4 */
            background-color: rgba(31, 41, 55, 0.8); /* gray-800 with opacity */
            color: white;
            font-size: 0.75rem; /* text-xs */
            line-height: 1rem;
            padding: 0.75rem; /* p-3 */
            border-radius: 0.5rem; /* rounded-lg */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* shadow-md */
            z-index: 10;
            pointer-events: none; /* Allow clicks to pass through */
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div class="flex h-screen">
        <div id="info-panel" class="p-6 bg-gray-800 rounded-r-lg shadow-lg border-l border-gray-700">
            <h2 class="text-2xl font-bold mb-4 text-gray-100">Body Information</h2>
            <div id="info-content" class="mt-4">
                <p class="text-gray-400">Loading model... Click on a body part after it appears.</p>
            </div>
        </div>

        <div id="canvas-container">
            <div id="loading-indicator">Loading Model... 0%</div>
            <div id="controls-guide">
                <b>Controls:</b><br>
                Orbit: Left Mouse Drag<br>
                Zoom: Mouse Wheel<br>
                Pan: Right Mouse Drag<br>
                Reset View: Double Click
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        // Import necessary Three.js modules
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- Global Variables ---
        let scene, camera, renderer, controls;
        let raycaster, mouse;
        let model;
        let initialCameraPosition = new THREE.Vector3(); // For reset
        let initialControlsTarget = new THREE.Vector3(); // For reset
        const canvasContainer = document.getElementById('canvas-container');
        const infoContent = document.getElementById('info-content');
        const loadingIndicator = document.getElementById('loading-indicator');

        // --- Bounding Box Zones ---
        // *** Adjust these values to fit your model accurately ***
        const headZone = new THREE.Box3(new THREE.Vector3(-0.4, 2.4, -0.4), new THREE.Vector3(0.4, 3.1, 0.4));
        const torsoZone = new THREE.Box3(new THREE.Vector3(-0.5, 0.9, -0.35), new THREE.Vector3(0.5, 2.4, 0.35));
        const leftArmZone = new THREE.Box3(new THREE.Vector3(-1.0, 0.8, -0.4), new THREE.Vector3(-0.4, 2.3, 0.4));
        const rightArmZone = new THREE.Box3(new THREE.Vector3(0.4, 0.8, -0.4), new THREE.Vector3(1.0, 2.3, 0.4));
        const legsZone = new THREE.Box3(new THREE.Vector3(-0.5, 0.0, -0.4), new THREE.Vector3(0.5, 1.0, 0.4));

        // Array for easier iteration when placing dots
        const clickableZones = [
            { zone: headZone, name: 'Head' },
            { zone: torsoZone, name: 'Torso / Chest' },
            { zone: leftArmZone, name: 'Left Arm' },
            { zone: rightArmZone, name: 'Right Arm' },
            { zone: legsZone, name: 'Legs / Lower Body' }
        ];

        // --- Dot Visualization ---
        const dotGeometry = new THREE.SphereGeometry(0.04, 16, 8); // Small sphere
        const dotMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.8 }); // Red, slightly transparent


        // --- Initialization ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);

            camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000);
            camera.position.set(0, 1.2, 5); // Initial position before model load

            renderer = new THREE.WebGLRenderer({ antialias: true });
            // *** Quick Win: Limit Pixel Ratio ***
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            canvasContainer.appendChild(renderer.domElement);

            // Lights
            // *** Quick Win: Use HemisphereLight ***
            const hemiLight = new THREE.HemisphereLight(0xadcafc, 0x404040, 1.5); // Soft sky/ground light
            scene.add(hemiLight);
            // Keep directional lights for highlights/shadows
            const dirLight1 = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight1.position.set(5, 10, 7.5);
            scene.add(dirLight1);
            const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight2.position.set(-5, -5, -7.5);
            scene.add(dirLight2);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 1.0, 0); // Initial target before model load
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = true; // Allow panning with right mouse
            controls.minDistance = 1;
            controls.maxDistance = 20;
            controls.update();

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // --- Load Model ---
            const loader = new GLTFLoader();
            const modelUrl = './human_body.glb';
            loadingIndicator.style.display = 'block';

            loader.load(
                modelUrl,
                function (gltf) { // Success
                    loadingIndicator.style.display = 'none';
                    model = gltf.scene;

                    // Center and Scale
                    const box = new THREE.Box3().setFromObject(model);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const desiredHeight = 3.0;
                    const scale = desiredHeight / maxDim;
                    model.scale.set(scale, scale, scale);
                    box.setFromObject(model);
                    box.getCenter(center);
                    model.position.sub(center);
                    model.position.y += (size.y * scale / 2);
                    scene.add(model);

                    // Update controls target and save initial state for reset
                    const modelCenterY = model.position.y + (size.y * scale * 0.5);
                    controls.target.set(model.position.x, modelCenterY, model.position.z);
                    initialCameraPosition.copy(camera.position); // Store initial camera pos
                    initialControlsTarget.copy(controls.target); // Store initial target
                    controls.saveState(); // Save state for potential controls.reset() use
                    controls.update();

                    // *** Add Clickable Zone Dots ***
                    clickableZones.forEach(item => {
                        const zoneCenter = item.zone.getCenter(new THREE.Vector3());
                        const dotMesh = new THREE.Mesh(dotGeometry, dotMaterial);
                        dotMesh.position.copy(zoneCenter);
                        dotMesh.name = item.name + " Zone Marker"; // Give marker a name
                        // Add dot directly to the scene, not as a child of the model
                        scene.add(dotMesh);
                    });
                    console.log("Added zone markers to scene.");


                    console.log('Model loaded successfully. Scaled height approx:', size.y * scale);
                    updateInfoPanel('', 'Model loaded. Click on a body part or double-click to reset view.');
                },
                function (xhr) { // Progress
                    const percentLoaded = Math.round((xhr.loaded / xhr.total) * 100);
                    loadingIndicator.textContent = `Loading Model... ${percentLoaded}%`;
                },
                function (error) { // Error
                    loadingIndicator.style.display = 'none';
                    console.error('An error happened loading the model:', error);
                    infoContent.innerHTML = `<p class="text-red-500">Error loading 3D model.</p>`;
                }
            );

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            canvasContainer.addEventListener('click', onClick);
            // *** Quick Win: Double-click listener ***
            canvasContainer.addEventListener('dblclick', onDoubleClick);

            animate();
        }

        // --- Handle Resize ---
        function onWindowResize() {
            if (!renderer || !camera || !canvasContainer) return;
            camera.aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
        }

         // --- Handle Double Click ---
         function onDoubleClick() {
            if (!controls || !initialCameraPosition || !initialControlsTarget) return;
            console.log("Resetting view...");
            // Reset camera and controls to the saved initial state
            camera.position.copy(initialCameraPosition);
            controls.target.copy(initialControlsTarget);
            controls.update(); // Crucial to apply the changes
         }

        // --- Handle Click ---
        function onClick(event) {
            if (!model) return;

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            // Intersect with the main model (recursively to find 'Group1' inside)
            // This will ignore the dots because they were added directly to the scene, not the 'model' group.
            const intersects = raycaster.intersectObject(model, true);

            if (intersects.length > 0) {
                const clickPoint = intersects[0].point;
                console.log('Click Point Coordinates:', clickPoint);

                let partName = 'Unknown Area';
                // *** Expanded Placeholder Descriptions ***
                let description = 'This part of the model is not specifically classified. Try clicking near one of the red dots.';

                // Check zones
                if (headZone.containsPoint(clickPoint)) {
                    partName = 'Head';
                    description = 'The head houses the brain, responsible for thought, memory, and controlling body functions. It also contains primary sensory organs like the eyes (vision), ears (hearing), nose (smell), and mouth (taste, speech, breathing). Key structures include the skull, brain, face, and neck attachment.';
                } else if (leftArmZone.containsPoint(clickPoint)) {
                    partName = 'Left Arm';
                    description = 'The left arm extends from the shoulder to the hand. It comprises the upper arm (humerus), forearm (radius, ulna), wrist, and hand. It allows for a wide range of motion, crucial for reaching, grasping, lifting, and fine motor skills.';
                } else if (rightArmZone.containsPoint(clickPoint)) {
                    partName = 'Right Arm';
                    description = 'The right arm, similar in structure to the left, extends from the shoulder to the hand. It includes the humerus, radius, ulna, wrist, and hand. It facilitates interaction with the environment through reaching, lifting, and manipulation.';
                } else if (torsoZone.containsPoint(clickPoint)) {
                    partName = 'Torso / Chest';
                    description = 'The torso is the central part of the body, connecting the head, neck, and limbs. It contains the chest cavity (heart, lungs, esophagus protected by ribs) and the abdominal cavity (stomach, intestines, liver, kidneys, etc.). It plays a vital role in protecting organs and enabling movement.';
                } else if (legsZone.containsPoint(clickPoint)) {
                    partName = 'Legs / Lower Body';
                    description = 'The legs support the body and enable locomotion (walking, running, jumping). Each leg consists of the thigh (femur), knee joint, lower leg (tibia, fibula), ankle, and foot. Strong muscles power movement and maintain balance.';
                }

                updateInfoPanel(partName, description);

            } else {
                updateInfoPanel('', 'Click on a body part in the model. Double-click to reset view.');
            }
        }

        // --- Update Info Panel ---
        function updateInfoPanel(title, text) {
            const displayTitle = title || 'Info';
            // *** Quick Win: Improved Styling/Structure ***
            infoContent.innerHTML = `
                <div class="bg-gray-700 p-4 rounded-md shadow">
                    <h3 class="text-xl font-semibold mb-2 text-blue-300 border-b border-gray-600 pb-1">${displayTitle}</h3>
                    <p class="text-gray-200 leading-relaxed text-sm">${text || 'Select a part for details.'}</p>
                </div>
            `;
             if (!title && !text) {
                 infoContent.innerHTML = `<p class="text-gray-400">Click on a body part. Double-click to reset view.</p>`;
             } else if (!title) {
                 // Fallback if only text is provided (shouldn't happen often with current logic)
                 infoContent.innerHTML = `<div class="bg-gray-700 p-3 rounded-md shadow"><p class="text-gray-200 leading-relaxed text-sm">${text}</p></div>`;
             }
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update();
            if (renderer) renderer.render(scene, camera);
        }

        // --- Start ---
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

    </script>

</body>
</html>
