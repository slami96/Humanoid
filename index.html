<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Body</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Basic styling */
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; }
        #canvas-container { flex-grow: 1; height: 100vh; position: relative; }
        #canvas-container canvas { display: block; width: 100%; height: 100%; cursor: grab; } /* Add grab cursor */
        #canvas-container canvas:active { cursor: grabbing; } /* Add grabbing cursor */
        #info-panel {
            width: 300px; /* Adjust width as needed */
            height: 100vh;
            overflow-y: auto;
            flex-shrink: 0;
        }
        #loading-indicator {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 1.2em; background-color: rgba(0,0,0,0.5);
            padding: 10px 15px; border-radius: 8px; display: none; z-index: 10;
        }
        #controls-guide {
            position: absolute; bottom: 1rem; right: 1rem;
            background-color: rgba(31, 41, 55, 0.8); color: white; font-size: 0.75rem;
            line-height: 1rem; padding: 0.75rem; border-radius: 0.5rem; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            z-index: 10; pointer-events: none; /* Allow clicks to pass through */
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div class="flex h-screen">
        <div id="info-panel" class="p-6 bg-gray-800 rounded-r-lg shadow-lg border-l border-gray-700">
            <h2 class="text-2xl font-bold mb-4 text-gray-100">Body Information</h2>
            <div id="info-content" class="mt-4">
                <p class="text-gray-400">Loading model... Click on a body part after it appears.</p>
            </div>
        </div>

        <div id="canvas-container">
            <div id="loading-indicator">Loading Model... 0%</div>
            <div id="controls-guide">
                <b>Controls:</b><br>
                Orbit: Left Mouse Drag<br>
                Zoom: Mouse Wheel<br>
                Pan: Right Mouse Drag<br>
                Reset View: Double Click
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- Global Variables ---
        let scene, camera, renderer, controls;
        let raycaster, mouse;
        let model;
        let initialCameraPosition = new THREE.Vector3(); // For reset
        let initialControlsTarget = new THREE.Vector3(); // For reset
        const canvasContainer = document.getElementById('canvas-container');
        const infoContent = document.getElementById('info-content');
        const loadingIndicator = document.getElementById('loading-indicator');

        // --- Bounding Box Zones ---
        // === IMPORTANT: ADJUST THESE VALUES TO FIT YOUR MODEL ===
        // You can visualize these boxes by uncommenting the "Visualize Bounding Boxes"
        // section later in the code (inside the loader.load success callback).
        const headZone = new THREE.Box3(
            new THREE.Vector3(-0.4, 2.4, -0.4), // Min(x, y, z)
            new THREE.Vector3(0.4, 3.1, 0.4)    // Max(x, y, z)
        );
        const torsoZone = new THREE.Box3(
            new THREE.Vector3(-0.5, 0.9, -0.35),
            new THREE.Vector3(0.5, 2.4, 0.35)
        );
        const leftArmZone = new THREE.Box3(
            new THREE.Vector3(-1.0, 0.8, -0.4),
            new THREE.Vector3(-0.4, 2.3, 0.4)
        );
        const rightArmZone = new THREE.Box3(
            new THREE.Vector3(0.4, 0.8, -0.4),
            new THREE.Vector3(1.0, 2.3, 0.4)
        );
        const legsZone = new THREE.Box3(
            new THREE.Vector3(-0.5, 0.0, -0.4),
            new THREE.Vector3(0.5, 1.0, 0.4)
        );
        // ========================================================

        // Array for iterating zones
        const clickableZones = [
            { zone: headZone, name: 'Head' },
            { zone: torsoZone, name: 'Torso / Chest' },
            { zone: leftArmZone, name: 'Left Arm' },
            { zone: rightArmZone, name: 'Right Arm' },
            { zone: legsZone, name: 'Legs / Lower Body' }
        ];

        // --- Dot Visualization ---
        // Made dots slightly larger and changed color
        const dotGeometry = new THREE.SphereGeometry(0.05, 16, 8); // Slightly larger radius
        const dotMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 }); // Yellow, opaque

        // To hold optional visual helpers for the zones
        let zoneHelpers = [];


        // --- Initialization ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);

            camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000);
            camera.position.set(0, 1.2, 5); // Initial position before model load

            renderer = new THREE.WebGLRenderer({ antialias: true });
            // Limit Pixel Ratio
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            canvasContainer.appendChild(renderer.domElement);

            // Lights
            // Use HemisphereLight
            const hemiLight = new THREE.HemisphereLight(0xadcafc, 0x404040, 1.5); // Soft sky/ground light
            scene.add(hemiLight);
            // Keep directional lights for highlights/shadows
            const dirLight1 = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight1.position.set(5, 10, 7.5);
            scene.add(dirLight1);
            const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight2.position.set(-5, -5, -7.5);
            scene.add(dirLight2);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 1.0, 0); // Initial target before model load
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = true; // Allow panning with right mouse
            controls.minDistance = 1;
            controls.maxDistance = 20;
            controls.update();

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // --- Load Model ---
            const loader = new GLTFLoader();
            const modelUrl = './human_body.glb';
            loadingIndicator.style.display = 'block';

            loader.load(
                modelUrl,
                function (gltf) { // Success
                    loadingIndicator.style.display = 'none';
                    model = gltf.scene;

                    // Center and Scale
                    const box = new THREE.Box3().setFromObject(model);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const desiredHeight = 3.0;
                    const scale = desiredHeight / maxDim;
                    model.scale.set(scale, scale, scale);
                    box.setFromObject(model); // Recalculate box after scaling
                    box.getCenter(center); // Update center
                    model.position.sub(center); // Move center to origin
                    model.position.y += (size.y * scale / 2); // Lift model base to y=0
                    scene.add(model);

                    // Update controls target and save initial state for reset
                    const modelCenterY = model.position.y + (size.y * scale * 0.5);
                    controls.target.set(model.position.x, modelCenterY, model.position.z);
                    initialCameraPosition.copy(camera.position); // Store initial camera pos
                    initialControlsTarget.copy(controls.target); // Store initial target
                    controls.saveState(); // Save state for potential controls.reset() use
                    controls.update();

                    // Add Zone Dots
                    clickableZones.forEach(item => {
                        const zoneCenter = item.zone.getCenter(new THREE.Vector3());
                        const dotMesh = new THREE.Mesh(dotGeometry, dotMaterial);
                        dotMesh.position.copy(zoneCenter);
                        dotMesh.name = item.name + " Zone Marker"; // Give marker a name
                        // Add dot directly to the scene, not as a child of the model
                        scene.add(dotMesh);
                    });
                    console.log("Added zone markers to scene.");


                    // --- Optional: Visualize Bounding Boxes ---
                    // === UNCOMMENT THE CODE BLOCK BELOW TO SEE THE ZONES ===
                    // This helps adjust the Box3 coordinates above for better accuracy.
                    // Remember to comment it back out for the final version.
                    /*
                    console.log("Adding zone helpers (colored boxes)...");
                    const colors = { Head: 0xff0000, 'Torso / Chest': 0x00ff00, 'Left Arm': 0x0000ff, 'Right Arm': 0xffff00, 'Legs / Lower Body': 0xff00ff };
                    zoneHelpers = []; // Clear previous helpers if any
                    clickableZones.forEach(item => {
                        const helperColor = colors[item.name] || 0x888888; // Default gray
                        const helper = new THREE.Box3Helper(item.zone, helperColor);
                        scene.add(helper);
                        zoneHelpers.push(helper); // Store helper if you need to remove/update later
                    });
                    console.log("Zone helpers added to scene.");
                    */
                    // ========================================================


                    console.log('Model loaded successfully. Scaled height approx:', size.y * scale);
                    updateInfoPanel('', 'Model loaded. Click on a body part or double-click to reset view.');
                },
                function (xhr) { // Progress
                    const percentLoaded = Math.round((xhr.loaded / xhr.total) * 100);
                    loadingIndicator.textContent = `Loading Model... ${percentLoaded}%`;
                },
                function (error) { // Error
                    loadingIndicator.style.display = 'none';
                    console.error('An error happened loading the model:', error);
                    infoContent.innerHTML = `<p class="text-red-500">Error loading 3D model.</p>`;
                }
            );

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            canvasContainer.addEventListener('click', onClick);
            // Double-click listener
            canvasContainer.addEventListener('dblclick', onDoubleClick);

            animate();
        }

        // --- Handle Resize ---
        function onWindowResize() {
            if (!renderer || !camera || !canvasContainer) return;
            camera.aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
        }

         // --- Handle Double Click ---
         function onDoubleClick() {
            if (!controls || !initialCameraPosition || !initialControlsTarget) return;
            console.log("Resetting view...");
            // Reset camera and controls to the saved initial state
            camera.position.copy(initialCameraPosition);
            controls.target.copy(initialControlsTarget);
            controls.update(); // Crucial to apply the changes
         }

        // --- Handle Click ---
        function onClick(event) {
            if (!model) return; // Model not loaded yet

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            // Intersect with the main model (recursively to find 'Group1' inside)
            // This will ignore the dots because they were added directly to the scene, not the 'model' group.
            const intersects = raycaster.intersectObject(model, true);

            if (intersects.length > 0) {
                // Get the exact 3D point of intersection on the model surface
                const clickPoint = intersects[0].point;
                console.log('Click Point Coordinates:', clickPoint);

                let partName = 'Unknown Area'; // Default
                // Expanded Placeholder Descriptions
                let description = 'This part of the model is not specifically classified. Try clicking near one of the yellow dots, or adjust the bounding zones in the code.';

                // Check which predefined zone contains the click point
                // Order matters: check smaller/more specific zones first if they overlap
                if (headZone.containsPoint(clickPoint)) {
                    partName = 'Head';
                    description = 'The head houses the brain, responsible for thought, memory, and controlling body functions. It also contains primary sensory organs like the eyes (vision), ears (hearing), nose (smell), and mouth (taste, speech, breathing). Key structures include the skull, brain, face, and neck attachment.';
                } else if (leftArmZone.containsPoint(clickPoint)) {
                    partName = 'Left Arm';
                    description = 'The left arm extends from the shoulder to the hand. It comprises the upper arm (humerus), forearm (radius, ulna), wrist, and hand. It allows for a wide range of motion, crucial for reaching, grasping, lifting, and fine motor skills.';
                } else if (rightArmZone.containsPoint(clickPoint)) {
                    partName = 'Right Arm';
                    description = 'The right arm, similar in structure to the left, extends from the shoulder to the hand. It includes the humerus, radius, ulna, wrist, and hand. It facilitates interaction with the environment through reaching, lifting, and manipulation.';
                } else if (torsoZone.containsPoint(clickPoint)) {
                    // Check torso after arms in case arms overlap torso zone slightly
                    partName = 'Torso / Chest';
                    description = 'The torso is the central part of the body, connecting the head, neck, and limbs. It contains the chest cavity (heart, lungs, esophagus protected by ribs) and the abdominal cavity (stomach, intestines, liver, kidneys, etc.). It plays a vital role in protecting organs and enabling movement.';
                } else if (legsZone.containsPoint(clickPoint)) {
                    partName = 'Legs / Lower Body';
                    description = 'The legs support the body and enable locomotion (walking, running, jumping). Each leg consists of the thigh (femur), knee joint, lower leg (tibia, fibula), ankle, and foot. Strong muscles power movement and maintain balance.';
                }
                // Add more 'else if' conditions here if you define more zones

                updateInfoPanel(partName, description);

            } else {
                // Clicked on the background
                updateInfoPanel('', 'Click on a body part in the model. Double-click to reset view.');
            }
        }

        // --- Update Info Panel ---
        function updateInfoPanel(title, text) {
            const displayTitle = title || 'Info';
            // Improved Styling/Structure
            infoContent.innerHTML = `
                <div class="bg-gray-700 p-4 rounded-md shadow space-y-2">
                    <h3 class="text-xl font-semibold text-yellow-300 border-b border-gray-600 pb-1">${displayTitle}</h3>
                    <p class="text-gray-200 leading-relaxed text-sm">${text || 'Select a part for details.'}</p>
                </div>
            `;
             if (!title && !text) { // Handle case where both are empty (e.g., background click)
                 infoContent.innerHTML = `<p class="text-gray-400">Click on a body part. Double-click to reset view.</p>`;
             } else if (!title) { // Handle case where only title is missing
                 infoContent.innerHTML = `<div class="bg-gray-700 p-3 rounded-md shadow space-y-2"><p class="text-gray-200 leading-relaxed text-sm">${text}</p></div>`;
             }
        }


        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update(); // Update controls if damping enabled
            if (renderer) renderer.render(scene, camera); // Render the scene
        }

        // --- Start ---
        // Ensure DOM is fully loaded before initializing Three.js
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

    </script>

</body>
</html>
